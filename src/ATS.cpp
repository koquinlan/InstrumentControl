#include "ATS.hpp"

#include <iostream>
#include <stdexcept>

#include <string>
#include <vector>

#include <cmath>
#include <algorithm>


ATS::ATS(int systemId, int boardId) {
    boardHandle = AlazarGetBoardBySystemID(systemId, boardId);
    if (boardHandle == NULL) {
        throw std::runtime_error("Unable to open board system ID " + std::to_string(systemId) + " board ID " + std::to_string(boardId) + "\n");
    }
}



ATS::~ATS() { 
    if (boardHandle != NULL) {
        AlazarClose(boardHandle);
        boardHandle = NULL;
    }
}



/**
 * @brief Configures the sample clock of the ATS9462.
 * 
 * @details This assumes that you are using a 10 MHz external reference clock. The effective sample rate is somewhat restricted; 
    the board's bare sample rate must be between 150 and 180 Msps in steps of 1 Msps. You may then define an arbitrary decimation 
    factor of an integer between 1 and 10,000.

    This code will perform a little bit of math to figure out the optimal sampling settings given the requested sampling rate, and 
    then return the actual sampling rate. If you request a standard sample rate such as 10 Msps, the card will agree.  If you want 
    something nonstandard such as 9.57 Msps, you will get an actual sampling rate which is very close, but not exact
 * 
 * @param requestedSampleRate desired sample rate in MHz
 * @return double - Actual sample rate generated by the board
 */
double ATS::setExternalSampleClock(double requestedSampleRate) {
    // Fix sample rate to be positive and less than the absolute maximum of 180 MHz
    requestedSampleRate = min(std::abs(requestedSampleRate), 180e6);

    // Establish the range of bare sample rates the board is capable of (150 MHz - 180 MHz with steps of 1 MHz)
    std::vector<int> bareSampleRates;
    for (int rate = (int)150e6; rate <= (int)180e6; rate += (int)1e6) {
        bareSampleRates.push_back(rate);
    }

    // Find the best decimation factor for each bare sample rate
    std::vector<int> decimationFactors;
    std::vector<double> effectiveSampleRates;
    for (int& rate : bareSampleRates) {
        int factor = (int) min(std::round((double)rate/requestedSampleRate),10000);

        decimationFactors.push_back(factor);
        effectiveSampleRates.push_back((double)rate/(double)factor);
    }


    // Find the closest bare sample rate & decimation factor pair to approximate the requested sample rate
    int bestIndex = 0;
    double minError = DBL_MAX;
    for (int i=0; i < effectiveSampleRates.size(); i++){
        double error = std::abs(effectiveSampleRates[i] - requestedSampleRate);

        if (error < minError){
            minError = error;
            bestIndex = i;

            if (minError == 0) {
                break;
            }
        }
    }

    // Send the sample rate to the card
    retCode = AlazarSetCaptureClock(
        boardHandle,			        // HANDLE -- board handle
        EXTERNAL_CLOCK_10MHz_REF,		// U32 -- clock source id
        bareSampleRates[bestIndex],		// U32 -- sample rate id
        CLOCK_EDGE_RISING,		        // U32 -- clock edge id
        decimationFactors[bestIndex]    // U32 -- clock decimation 
    );
	if (retCode != ApiSuccess) {
		throw std::runtime_error(std::string("Error: AlazarSetCaptureClock failed -- ") + AlazarErrorToText(retCode) + "\n");
	}

    return effectiveSampleRates[bestIndex];
}



/**
 * @brief Sets up the input parameters for a particular channel
 * 
 * @param channel           'a' or 'b'              - which channel to set
 * @param coupling          'dc' or 'ac'            - coupling mode
 * @param inputRange        0.2, 0.4, 0.8 or 2 V    - full scale voltage range
 * @param inputImpedance    50 or 1e6 ohms          - input impedance
 */
void ATS::setInputParameters(char channel, std::string coupling, double inputRange, double inputImpedance) {
    channel = std::toupper(channel);

    // Get the channel ID
    int channelID;
    if      (channel == 'A') { channelID = CHANNEL_A; } 
    else if (channel == 'B') { channelID = CHANNEL_B; } 
    else {
        throw std::runtime_error("Invalid channel selection. Select channel 'A' or 'B'");
    }

    // Get the coupling mode
    int couplingMode;
    if (coupling == "DC" || coupling == "dc")       { couplingMode = DC_COUPLING; } 
    else if (coupling == "AC" || coupling == "ac")  { couplingMode = AC_COUPLING; } 
    else {
        throw std::runtime_error("Invalid coupling selection. Select 'DC' or 'AC'");
    }

    // Get the input range ID
    int rangeID;
    if (inputRange <= 0.2) {
        rangeID = INPUT_RANGE_PM_200_MV;
        inputRange = 0.2;
    } else if (inputRange <= 0.4) {
        rangeID = INPUT_RANGE_PM_400_MV;
        inputRange = 0.4;
    } else if (inputRange <= 0.8) {
        rangeID = INPUT_RANGE_PM_800_MV;
        inputRange = 0.8;
    } else {
        rangeID = INPUT_RANGE_PM_2_V;
        inputRange = 2.0;
    }

    // Get the input impedance ID (I believe the 9462 only accepts 50 ohm or 1 Mohm)
    int impedanceID;
    if (inputImpedance <= 50) {
        impedanceID = IMPEDANCE_50_OHM;
        inputImpedance = 50;
    // } else if (inputImpedance <= 75) {
    //     impedanceID = IMPEDANCE_75_OHM;
    //     inputImpedance = 75;
    // } else if (inputImpedance <= 300) {
    //     impedanceID = IMPEDANCE_300_OHM;
    //     inputImpedance = 300;
    } else {
        impedanceID = IMPEDANCE_1M_OHM;
        inputImpedance = 1e6;
    }

    // Call AlazarInputControl to set the input parameters
    retCode = AlazarInputControl(
        boardHandle,			// HANDLE -- board handle
        channelID,				// U8 -- channel identifier
        couplingMode,			// U32 -- input coupling id
        rangeID,	            // U32 -- input range id
        impedanceID     		// U32 -- input impedance id
    );
    if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarInputControl failed -- ") + AlazarErrorToText(retCode) + "\n");
    }
}