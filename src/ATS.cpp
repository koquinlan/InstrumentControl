#include "ATS.hpp"

#include <iostream>
#include <fstream>
#include <stdexcept>
#include <stdio.h>
#include <conio.h>

#include <string>
#include <vector>

#include <cmath>
#include <algorithm>


ATS::ATS(int systemId, int boardId) {
    boardHandle = AlazarGetBoardBySystemID(systemId, boardId);
    if (boardHandle == NULL) {
        throw std::runtime_error("Unable to open board system ID " + std::to_string(systemId) + " board ID " + std::to_string(boardId) + "\n");
    }
}



ATS::~ATS() { 
    if (boardHandle != NULL) {
        AlazarClose(boardHandle);
        boardHandle = NULL;
    }
}



/**
 * @brief Configures the sample clock of the ATS9462.
 * 
 * @details This assumes that you are using a 10 MHz external reference clock. The effective sample rate is somewhat restricted; 
    the board's bare sample rate must be between 150 and 180 Msps in steps of 1 Msps. You may then define an arbitrary decimation 
    factor of an integer between 1 and 10,000.

    This code will perform a little bit of math to figure out the optimal sampling settings given the requested sampling rate, and 
    then return the actual sampling rate. If you request a standard sample rate such as 10 Msps, the card will agree.  If you want 
    something nonstandard such as 9.57 Msps, you will get an actual sampling rate which is very close, but not exact
 * 
 * @param requestedSampleRate desired sample rate in MHz
 * @return double - Actual sample rate generated by the board
 */
double ATS::setExternalSampleClock(double requestedSampleRate) {
    // Fix sample rate to be positive and less than the absolute maximum of 180 MHz
    requestedSampleRate = min(std::abs(requestedSampleRate), 180e6);

    // Establish the range of bare sample rates the board is capable of (150 MHz - 180 MHz with steps of 1 MHz)
    std::vector<int> bareSampleRates;
    for (int rate = (int)150e6; rate <= (int)180e6; rate += (int)1e6) {
        bareSampleRates.push_back(rate);
    }

    // Find the best decimation factor for each bare sample rate
    std::vector<int> decimationFactors;
    std::vector<double> effectiveSampleRates;
    for (int& rate : bareSampleRates) {
        int factor = (int) min(std::round((double)rate/requestedSampleRate),10000);

        decimationFactors.push_back(factor);
        effectiveSampleRates.push_back((double)rate/(double)factor);
    }


    // Find the closest bare sample rate & decimation factor pair to approximate the requested sample rate
    int bestIndex = 0;
    double minError = DBL_MAX;
    for (int i=0; i < effectiveSampleRates.size(); i++){
        double error = std::abs(effectiveSampleRates[i] - requestedSampleRate);

        if (error < minError){
            minError = error;
            bestIndex = i;

            if (minError == 0) {
                break;
            }
        }
    }

    // Send the sample rate to the card
    retCode = AlazarSetCaptureClock(
        boardHandle,			        // HANDLE -- board handle
        EXTERNAL_CLOCK_10MHz_REF,		// U32 -- clock source id
        bareSampleRates[bestIndex],		// U32 -- sample rate id
        CLOCK_EDGE_RISING,		        // U32 -- clock edge id
        decimationFactors[bestIndex]    // U32 -- clock decimation 
    );
	if (retCode != ApiSuccess) {
		throw std::runtime_error(std::string("Error: AlazarSetCaptureClock failed -- ") + AlazarErrorToText(retCode) + "\n");
	}

    return effectiveSampleRates[bestIndex];
}



/**
 * @brief Sets up the input parameters for a particular channel
 * 
 * @param channel           'a' or 'b'              - which channel to set
 * @param coupling          'dc' or 'ac'            - coupling mode
 * @param inputRange        0.2, 0.4, 0.8 or 2 V    - full scale voltage range
 * @param inputImpedance    50 or 1e6 ohms          - input impedance
 */
void ATS::setInputParameters(char channel, std::string coupling, double inputRange, double inputImpedance) {
    // Get the channel ID
    int channelID = getChannelID(channel);

    // Get the coupling mode
    int couplingMode;
    if (coupling == "DC" || coupling == "dc")       { couplingMode = DC_COUPLING; } 
    else if (coupling == "AC" || coupling == "ac")  { couplingMode = AC_COUPLING; } 
    else {
        throw std::runtime_error("Invalid coupling selection. Select 'DC' or 'AC'");
    }

    // Get the input range ID
    int rangeID;
    if (inputRange <= 0.2) {
        rangeID = INPUT_RANGE_PM_200_MV;
        inputRange = 0.2;
    } else if (inputRange <= 0.4) {
        rangeID = INPUT_RANGE_PM_400_MV;
        inputRange = 0.4;
    } else if (inputRange <= 0.8) {
        rangeID = INPUT_RANGE_PM_800_MV;
        inputRange = 0.8;
    } else {
        rangeID = INPUT_RANGE_PM_2_V;
        inputRange = 2.0;
    }

    // Get the input impedance ID (I believe the 9462 only accepts 50 ohm or 1 Mohm)
    int impedanceID;
    if (inputImpedance <= 50) {
        impedanceID = IMPEDANCE_50_OHM;
        inputImpedance = 50;
    // } else if (inputImpedance <= 75) {
    //     impedanceID = IMPEDANCE_75_OHM;
    //     inputImpedance = 75;
    // } else if (inputImpedance <= 300) {
    //     impedanceID = IMPEDANCE_300_OHM;
    //     inputImpedance = 300;
    } else {
        impedanceID = IMPEDANCE_1M_OHM;
        inputImpedance = 1e6;
    }

    // Call AlazarInputControl to set the input parameters
    retCode = AlazarInputControl(
        boardHandle,			// HANDLE -- board handle
        channelID,				// U8 -- channel identifier
        couplingMode,			// U32 -- input coupling id
        rangeID,	            // U32 -- input range id
        impedanceID     		// U32 -- input impedance id
    );
    if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarInputControl failed -- ") + AlazarErrorToText(retCode) + "\n");
    }
}



void ATS::setBandwidthLimit(char channel, bool limit) {
    int channelID = getChannelID(channel);

    retCode = AlazarSetBWLimit(
        boardHandle,			// HANDLE -- board handle
        channelID,				// U8 -- channel identifier
        limit					// U32 -- 0 = disable, 1 = enable
    );
    if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarSetBWLimit failed -- ") + AlazarErrorToText(retCode) + "\n");
    }
}



int ATS::getChannelID(char channel){
    int channelID;
    channel = std::toupper(channel);
    
    if      (channel == 'A') { channelID = CHANNEL_A; } 
    else if (channel == 'B') { channelID = CHANNEL_B; } 
    else {
        throw std::runtime_error("Invalid channel selection. Select channel 'A' or 'B'");
    }

    return channelID;
}



void ATS::AcquireData() {
    // Set which channels to capture over
    U32 channelMask = CHANNEL_A | CHANNEL_B;
    int channelCount = 2; 

    // Get the sample size in bits, and the on-board memory size in samples per channel
	U8 bitsPerSample;
	U32 maxSamplesPerChannel;
	RETURN_CODE retCode = AlazarGetChannelInfo(boardHandle, &maxSamplesPerChannel, &bitsPerSample);
	if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarGetChannelInfo failed -- ") + AlazarErrorToText(retCode) + "\n");
	}


    // Passed in to matlab function
    U32 sampleRate = (U32)30e6;                  // Sample rate in Hz                - freq span = sampleRate/2
    U32 samplesPerRecord = (U32)150e3;          // Samples per single shot of ATS
    U32 recordsPerAcquisition = 64;   
    U32 buffersPerAcquisition = 1;

    // Done inside matlab function
    U32 recordsPerBuffer = std::round(recordsPerAcquisition/buffersPerAcquisition);
    U32 samplesPerBuffer = samplesPerRecord*recordsPerBuffer;
    U32 bytesPerSample = (bitsPerSample + 7) / 8;
	U32 bytesPerBuffer = bytesPerSample * samplesPerBuffer * channelCount;

    U32 realRecordsPerBuffer = 1;                                              
    U32 realRecordsPerAcquisition = buffersPerAcquisition;
    U32 realSamplesPerRecord = samplesPerBuffer;


    setExternalSampleClock(sampleRate);

    setInputParameters('a', "dc", 0.8);
    setBandwidthLimit('a', 1);

    setInputParameters('b', "dc", 0.8);
    setBandwidthLimit('b', 1);

    // // Set parameters for acquisition (should be input to function)
    // U32 sampleRate = (U32)30e6;                  // Sample rate in Hz                - freq span = sampleRate/2
    // U32 samplesPerRecord = (U32)15e4;          // Samples per single shot of ATS
    // U32 buffersPerAcquisition = 64;
    // U32 recordsPerAcquisition = 64;       
    // U32 recordsPerBuffer = 1;
    // double inputRange = 0.4;
    

    // Calculate remaining parameters
    // U32 samplesPerBuffer = samplesPerRecord*recordsPerBuffer;
    // U32 bytesPerSample = (bitsPerSample + 7) / 8;
	// U32 bytesPerBuffer = bytesPerSample * samplesPerBuffer * channelCount;

    // INT64 samplesPerAcquisition = (INT64) (samplesPerBuffer * buffersPerAcquisition + 0.5);


    retCode = AlazarSetRecordSize(
        boardHandle,			    // HANDLE -- board handle
        0,
        samplesPerRecord*(recordsPerAcquisition)/buffersPerAcquisition
    );
    if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarSetRecordSize failed -- ") + AlazarErrorToText(retCode) + "\n");
    }


    retCode = AlazarSetRecordCount(
        boardHandle,			    // HANDLE -- board handle
        buffersPerAcquisition			    
    );
    if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarSetRecordCount failed -- ") + AlazarErrorToText(retCode) + "\n");
    }


    // Allocate memory for DMA buffers
	int bufferIndex;
	for (bufferIndex = 0; bufferIndex < BUFFER_COUNT; bufferIndex++)
	{
		IoBufferArray[bufferIndex] = CreateIoBuffer(bytesPerBuffer);
		if (IoBufferArray[bufferIndex] == NULL) {
            throw std::runtime_error(std::string("Error: Alloc ") + AlazarErrorToText(retCode) +  "bytes failed\n");
		}
	}


	// Create a data file if required
    BOOL saveData = TRUE;
	FILE *fpData = NULL;

	if (saveData)
	{
		fpData = fopen("data.bin", "wb");
		if (fpData == NULL)
		{
			printf("Error: Unable to create data file -- %u\n", GetLastError());
		}
	}


    // Configure the board to make an AutoDMA acquisition
    U32 admaFlags = ADMA_EXTERNAL_STARTCAPTURE;         // Start acquisition when AlazarStartCapture is called
    // U32 admaFlags = ADMA_EXTERNAL_STARTCAPTURE |	
    //                 ADMA_CONTINUOUS_MODE;			// Acquire a continuous stream of sample data without trigger

    retCode = AlazarBeforeAsyncRead(
        boardHandle,			    // HANDLE -- board handle
        channelMask,			    // U32 -- enabled channel mask
        0,						    // long -- offset from trigger in samples
        realSamplesPerRecord,		// U32 -- samples per buffer
        realRecordsPerBuffer,		// U32 -- records per buffer (must be 1)
        realRecordsPerAcquisition,	// U32 -- records per acquisition 
        admaFlags				    // U32 -- AutoDMA flags
    ); 
    if (retCode != ApiSuccess) {
        throw std::runtime_error(std::string("Error: AlazarBeforeAsyncRead failed -- ") + AlazarErrorToText(retCode) + "\n");
    }
	


	// Add the buffers to a list of buffers available to be filled by the board
    bool success = TRUE;

	for (bufferIndex = 0; (bufferIndex < BUFFER_COUNT) && (success == TRUE); bufferIndex++)
	{
		IO_BUFFER *pIoBuffer = IoBufferArray[bufferIndex];
		if (!ResetIoBuffer(pIoBuffer)) {
			success = FALSE;
		}
		else {
			retCode = AlazarPostAsyncBuffer(
                boardHandle,					// HANDLE -- board handle
                pIoBuffer->pBuffer,				// void* -- buffer
                pIoBuffer->uBufferLength_bytes	// U32 -- buffer length in bytes
            );				
			if (retCode != ApiSuccess) {
                throw std::runtime_error(std::string("Error: AlazarAsyncRead ") + std::to_string(bufferIndex) + 
                                                     " failed -- " + AlazarErrorToText(retCode) + "\n");
			}
		}
	}


	// Arm the board to begin the acquisition 
	if (success) {
		retCode = AlazarStartCapture(boardHandle);
		if (retCode != ApiSuccess) {
			throw std::runtime_error(std::string("Error: AlazarStartCapture failed -- ") + AlazarErrorToText(retCode) + "\n");
            success = false;
		}
	}

    // pause(0.05);


	// Wait for each buffer to be filled, process the buffer, and re-post it to the board.
	if (success) {
		printf("Capturing %d buffers ... press any key to abort\n", buffersPerAcquisition);

		DWORD startTickCount = GetTickCount();
		U32 buffersCompleted = 0;
		INT64 bytesTransferred = 0;
		
		while (buffersCompleted < buffersPerAcquisition) {
            // Send a software trigger to begin acquisition (in theory unnecessary...)
            retCode = AlazarForceTrigger(boardHandle);
            if (retCode != ApiSuccess) {
                throw std::runtime_error(std::string("Error: Trigger failed to send -- ") + AlazarErrorToText(retCode) + "\n");
            }


            // Timeout after 10x the expected time for 1 buffer
            DWORD timeout_ms = (DWORD)5000; 
			// DWORD timeout_ms = (DWORD)(10*1e3*samplesPerBuffer/sampleRate); 

			// Wait for the buffer at the head of the list of available buffers to be filled by the board.
			bufferIndex = buffersCompleted % BUFFER_COUNT;
			IO_BUFFER *pIoBuffer = IoBufferArray[bufferIndex];
			retCode = AlazarWaitAsyncBufferComplete(
                boardHandle, 
                pIoBuffer->pBuffer, 
                timeout_ms
            );

			if (retCode == ApiSuccess) {
                // This buffer is full and has been removed from the list
				// of buffers available to the board.

				buffersCompleted++;
				bytesTransferred += bytesPerBuffer;

				// While you are processing this buffer, the board is 
				// filling the next available buffer(s). You must finish 
				// processing this buffer and make it available to the 
				// board before the board fills all available buffer(s). 
				// 
				// Records in the buffer are arranged as follows: R0A, R0B,
				// where Rxy is a segment of a single record.
				//
				// Sample values for ecah enabled channel are arranged 
				// contiguously in the buffer, with a 16-bit sample code in
				// in each 16-bit sample value.
				//
				// Sample codes are unsigned by default so that:
				// - a sample code of 0x0000 represents a negative full scale input signal;
				// - a sample code of 0x8000 represents a 0V signal;
				// - a sample code of 0xFFFF represents a positive full scale input signal;

				if (saveData) {
					// Write buffer to file
					size_t bytesWritten = fwrite(pIoBuffer->pBuffer, sizeof(BYTE), bytesPerBuffer, fpData);
					if (bytesWritten != bytesPerBuffer)
					{
						printf("Error: Write buffer %d failed -- %u\n", buffersCompleted, GetLastError());
						success = FALSE;
					}
				}
            }
			else {
				// The wait failed
				success = FALSE;

				switch (retCode)
				{
				case ApiWaitTimeout:
					printf("Error: Wait timeout after %lu ms\n", timeout_ms);
					break;

				case ApiBufferOverflow:
					printf("Error: Board overflowed on-board memory\n");
					break;

                case ApiBufferNotReady:
					printf("Error: Buffer not found in list of available\n");
					break;

                case ApiDmaInProgress:
					printf("Error: Buffer not at the head of available buffers\n");
					break;

				default:
					printf("Error: Wait failed with error %lu -- %s\n", GetLastError());
					break;
				}
			}


			// Add the buffer to the end of the list of available buffers so that 
			// the board can fill it with data from another segment of the acquisition.
			if (success) {
				if (!ResetIoBuffer (pIoBuffer)) {
					success = FALSE;
				}
				else {
                    retCode = AlazarPostAsyncBuffer(
                        boardHandle,					// HANDLE -- board handle
                        pIoBuffer->pBuffer,				// void* -- buffer
                        pIoBuffer->uBufferLength_bytes	// U32 -- buffer length in bytes
                    );		
					if (retCode != ApiSuccess) {
						printf("Error: AlazarPostAsyncBuffer failed -- %s\n", AlazarErrorToText(retCode));
						success = FALSE;
					}
				}
			}


			// If the acquisition failed, exit the acquisition loop
			if (!success) {
				break;
            }
	
			// If a key was pressed, exit the acquisition loop					
			if (_kbhit()) {
				printf("Aborted...\n");
				break;
			}

			// Display progress
			printf("Completed %u buffers\r", buffersCompleted);
		}

		// Display results
		double transferTime_sec = (GetTickCount() - startTickCount) / 1000.;
		printf("Capture completed in %.3lf sec\n", transferTime_sec);

		double buffersPerSec;
		double bytesPerSec;
		if (transferTime_sec > 0.)
		{
			buffersPerSec = buffersCompleted / transferTime_sec;
			bytesPerSec = bytesTransferred / transferTime_sec;
		}
		else
		{
			buffersPerSec = 0.;
			bytesPerSec = 0.;
		}

		printf("Captured %d buffers (%.4g buffers per sec)\n", buffersCompleted, buffersPerSec);
		printf("Transferred %I64d bytes (%.4g bytes per sec)\n", bytesTransferred, bytesPerSec);
	}

	// Abort the acquisition
	retCode = AlazarAbortAsyncRead(boardHandle);
	if (retCode != ApiSuccess) {
		printf("Error: AlazarAbortAsyncRead failed -- %s\n", AlazarErrorToText(retCode));
		success = FALSE;
	}

	// Free all memory allocated

	for (bufferIndex = 0; bufferIndex < BUFFER_COUNT; bufferIndex++) {
		if (IoBufferArray[bufferIndex] != NULL)
			DestroyIoBuffer(IoBufferArray[bufferIndex]);
	}

	// Close the data file
	if (fpData != NULL)
		fclose(fpData);
}


// std::vector<double> channel1Data;
// std::vector<double> channel2Data;

// for (int sampleIndex = 0; sampleIndex < (int)samplesPerBuffer; sampleIndex++) {
//     // Calculate the index of the sample for each channel
//     int channelASampleIndex = sampleIndex * channelCount;
//     int channelBSampleIndex = channelASampleIndex + 1;

//     // Get the sample values for each channel
//     unsigned short channelASample = reinterpret_cast<unsigned short*>(pIoBuffer->pBuffer)[channelASampleIndex];
//     unsigned short channelBSample = reinterpret_cast<unsigned short*>(pIoBuffer->pBuffer)[channelBSampleIndex];

//     // Convert the sample values to voltages
//     double channelAVoltage = (channelASample/0xFFFF) * 2 * inputRange;
//     double channelBVoltage = (channelBSample/0xFFFF) * 2 * inputRange;

//     // Store the voltage values in the corresponding vectors
//     channel1Data.push_back(channelAVoltage - inputRange);
//     channel2Data.push_back(channelBVoltage - inputRange);
// }


std::vector<double> ATS::processData() {
    // Set parameters for acquisition (should be input to function)
    double inputRange = 0.4;
	double freqBinWidth = 200;              // Width in Hz of each bin in post-FFT data     - RBW = sampleRate/sampleNum
    double sampleRate = 30e6;               // Sample rate in Hz                            - freq span = sampleRate/2
    int totalRecordsPerAcquisition = 64;    // Records per single shot of ATS               - each record has RBW as given above
    int recordsPerBuffer = 1;               // Number of records in each DMA buffer         - must be set to 1 in continuous streaming DMA

    // Calculate remaining parameters
    U32 samplesPerBuffer = (U32)(sampleRate/freqBinWidth*recordsPerBuffer);

    std::string filename = "data.bin";

    // Open the binary file
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Error: Failed to open file");
    }

    // Get the file size
    file.seekg(0, std::ios::end);
    std::streampos fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    // Calculate the number of samples
    std::size_t sampleCount = fileSize / sizeof(unsigned short);

    // Read the sample data
    std::vector<unsigned short> sampleData(sampleCount);
    if (!file.read(reinterpret_cast<char*>(sampleData.data()), fileSize)) {
        throw std::runtime_error("Error: Failed to read sample data");
    }

    // Convert the sample data to voltage values
    std::vector<double> voltageDataA;
    std::vector<double> voltageDataB;

    voltageDataA.reserve(sampleCount);
    voltageDataB.reserve(sampleCount);
    for (std::size_t i = 0; i < sampleCount/2; ++i) {
        double voltageA = (sampleData[2*i]   / (double)0xFFFF) * 2 * inputRange;
        double voltageB = (sampleData[2*i+1] / (double)0xFFFF) * 2 * inputRange;

        voltageDataA.push_back(voltageA - inputRange);
        voltageDataB.push_back(voltageB - inputRange);
    }

    return voltageDataA;
}
